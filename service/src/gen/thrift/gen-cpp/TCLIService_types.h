/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef TCLIService_TYPES_H
#define TCLIService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace apache { namespace hive { namespace service { namespace cli { namespace thrift {

struct TProtocolVersion {
  enum type {
    HIVE_CLI_SERVICE_PROTOCOL_V1 = 0,
    HIVE_CLI_SERVICE_PROTOCOL_V2 = 1,
    HIVE_CLI_SERVICE_PROTOCOL_V3 = 2,
    HIVE_CLI_SERVICE_PROTOCOL_V4 = 3,
    HIVE_CLI_SERVICE_PROTOCOL_V5 = 4,
    HIVE_CLI_SERVICE_PROTOCOL_V6 = 5,
    HIVE_CLI_SERVICE_PROTOCOL_V7 = 6,
    HIVE_CLI_SERVICE_PROTOCOL_V8 = 7
  };
};

extern const std::map<int, const char*> _TProtocolVersion_VALUES_TO_NAMES;

struct TTypeId {
  enum type {
    BOOLEAN_TYPE = 0,
    TINYINT_TYPE = 1,
    SMALLINT_TYPE = 2,
    INT_TYPE = 3,
    BIGINT_TYPE = 4,
    FLOAT_TYPE = 5,
    DOUBLE_TYPE = 6,
    STRING_TYPE = 7,
    TIMESTAMP_TYPE = 8,
    BINARY_TYPE = 9,
    ARRAY_TYPE = 10,
    MAP_TYPE = 11,
    STRUCT_TYPE = 12,
    UNION_TYPE = 13,
    USER_DEFINED_TYPE = 14,
    DECIMAL_TYPE = 15,
    NULL_TYPE = 16,
    DATE_TYPE = 17,
    VARCHAR_TYPE = 18,
    CHAR_TYPE = 19,
    INTERVAL_YEAR_MONTH_TYPE = 20,
    INTERVAL_DAY_TIME_TYPE = 21
  };
};

extern const std::map<int, const char*> _TTypeId_VALUES_TO_NAMES;

struct TStatusCode {
  enum type {
    SUCCESS_STATUS = 0,
    SUCCESS_WITH_INFO_STATUS = 1,
    STILL_EXECUTING_STATUS = 2,
    ERROR_STATUS = 3,
    INVALID_HANDLE_STATUS = 4
  };
};

extern const std::map<int, const char*> _TStatusCode_VALUES_TO_NAMES;

struct TOperationState {
  enum type {
    INITIALIZED_STATE = 0,
    RUNNING_STATE = 1,
    FINISHED_STATE = 2,
    CANCELED_STATE = 3,
    CLOSED_STATE = 4,
    ERROR_STATE = 5,
    UKNOWN_STATE = 6,
    PENDING_STATE = 7
  };
};

extern const std::map<int, const char*> _TOperationState_VALUES_TO_NAMES;

struct TOperationType {
  enum type {
    EXECUTE_STATEMENT = 0,
    GET_TYPE_INFO = 1,
    GET_CATALOGS = 2,
    GET_SCHEMAS = 3,
    GET_TABLES = 4,
    GET_TABLE_TYPES = 5,
    GET_COLUMNS = 6,
    GET_FUNCTIONS = 7,
    UNKNOWN = 8
  };
};

extern const std::map<int, const char*> _TOperationType_VALUES_TO_NAMES;

struct TGetInfoType {
  enum type {
    CLI_MAX_DRIVER_CONNECTIONS = 0,
    CLI_MAX_CONCURRENT_ACTIVITIES = 1,
    CLI_DATA_SOURCE_NAME = 2,
    CLI_FETCH_DIRECTION = 8,
    CLI_SERVER_NAME = 13,
    CLI_SEARCH_PATTERN_ESCAPE = 14,
    CLI_DBMS_NAME = 17,
    CLI_DBMS_VER = 18,
    CLI_ACCESSIBLE_TABLES = 19,
    CLI_ACCESSIBLE_PROCEDURES = 20,
    CLI_CURSOR_COMMIT_BEHAVIOR = 23,
    CLI_DATA_SOURCE_READ_ONLY = 25,
    CLI_DEFAULT_TXN_ISOLATION = 26,
    CLI_IDENTIFIER_CASE = 28,
    CLI_IDENTIFIER_QUOTE_CHAR = 29,
    CLI_MAX_COLUMN_NAME_LEN = 30,
    CLI_MAX_CURSOR_NAME_LEN = 31,
    CLI_MAX_SCHEMA_NAME_LEN = 32,
    CLI_MAX_CATALOG_NAME_LEN = 34,
    CLI_MAX_TABLE_NAME_LEN = 35,
    CLI_SCROLL_CONCURRENCY = 43,
    CLI_TXN_CAPABLE = 46,
    CLI_USER_NAME = 47,
    CLI_TXN_ISOLATION_OPTION = 72,
    CLI_INTEGRITY = 73,
    CLI_GETDATA_EXTENSIONS = 81,
    CLI_NULL_COLLATION = 85,
    CLI_ALTER_TABLE = 86,
    CLI_ORDER_BY_COLUMNS_IN_SELECT = 90,
    CLI_SPECIAL_CHARACTERS = 94,
    CLI_MAX_COLUMNS_IN_GROUP_BY = 97,
    CLI_MAX_COLUMNS_IN_INDEX = 98,
    CLI_MAX_COLUMNS_IN_ORDER_BY = 99,
    CLI_MAX_COLUMNS_IN_SELECT = 100,
    CLI_MAX_COLUMNS_IN_TABLE = 101,
    CLI_MAX_INDEX_SIZE = 102,
    CLI_MAX_ROW_SIZE = 104,
    CLI_MAX_STATEMENT_LEN = 105,
    CLI_MAX_TABLES_IN_SELECT = 106,
    CLI_MAX_USER_NAME_LEN = 107,
    CLI_OJ_CAPABILITIES = 115,
    CLI_XOPEN_CLI_YEAR = 10000,
    CLI_CURSOR_SENSITIVITY = 10001,
    CLI_DESCRIBE_PARAMETER = 10002,
    CLI_CATALOG_NAME = 10003,
    CLI_COLLATION_SEQ = 10004,
    CLI_MAX_IDENTIFIER_LEN = 10005
  };
};

extern const std::map<int, const char*> _TGetInfoType_VALUES_TO_NAMES;

struct TFetchOrientation {
  enum type {
    FETCH_NEXT = 0,
    FETCH_PRIOR = 1,
    FETCH_RELATIVE = 2,
    FETCH_ABSOLUTE = 3,
    FETCH_FIRST = 4,
    FETCH_LAST = 5
  };
};

extern const std::map<int, const char*> _TFetchOrientation_VALUES_TO_NAMES;

typedef int32_t TTypeEntryPtr;

typedef std::string TIdentifier;

typedef std::string TPattern;

typedef std::string TPatternOrIdentifier;

typedef struct _TTypeQualifierValue__isset {
  _TTypeQualifierValue__isset() : i32Value(false), stringValue(false) {}
  bool i32Value;
  bool stringValue;
} _TTypeQualifierValue__isset;

class TTypeQualifierValue {
 public:

  static const char* ascii_fingerprint; // = "A7801670116150C65ACA43E6F679BA79";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x80,0x16,0x70,0x11,0x61,0x50,0xC6,0x5A,0xCA,0x43,0xE6,0xF6,0x79,0xBA,0x79};

  TTypeQualifierValue() : i32Value(0), stringValue() {
  }

  virtual ~TTypeQualifierValue() throw() {}

  int32_t i32Value;
  std::string stringValue;

  _TTypeQualifierValue__isset __isset;

  void __set_i32Value(const int32_t val) {
    i32Value = val;
    __isset.i32Value = true;
  }

  void __set_stringValue(const std::string& val) {
    stringValue = val;
    __isset.stringValue = true;
  }

  bool operator == (const TTypeQualifierValue & rhs) const
  {
    if (__isset.i32Value != rhs.__isset.i32Value)
      return false;
    else if (__isset.i32Value && !(i32Value == rhs.i32Value))
      return false;
    if (__isset.stringValue != rhs.__isset.stringValue)
      return false;
    else if (__isset.stringValue && !(stringValue == rhs.stringValue))
      return false;
    return true;
  }
  bool operator != (const TTypeQualifierValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeQualifierValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeQualifierValue &a, TTypeQualifierValue &b);


class TTypeQualifiers {
 public:

  static const char* ascii_fingerprint; // = "6C72981CFA989214285648FA8C196C47";
  static const uint8_t binary_fingerprint[16]; // = {0x6C,0x72,0x98,0x1C,0xFA,0x98,0x92,0x14,0x28,0x56,0x48,0xFA,0x8C,0x19,0x6C,0x47};

  TTypeQualifiers() {
  }

  virtual ~TTypeQualifiers() throw() {}

  std::map<std::string, TTypeQualifierValue>  qualifiers;

  void __set_qualifiers(const std::map<std::string, TTypeQualifierValue> & val) {
    qualifiers = val;
  }

  bool operator == (const TTypeQualifiers & rhs) const
  {
    if (!(qualifiers == rhs.qualifiers))
      return false;
    return true;
  }
  bool operator != (const TTypeQualifiers &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeQualifiers & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeQualifiers &a, TTypeQualifiers &b);

typedef struct _TPrimitiveTypeEntry__isset {
  _TPrimitiveTypeEntry__isset() : typeQualifiers(false) {}
  bool typeQualifiers;
} _TPrimitiveTypeEntry__isset;

class TPrimitiveTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "755674F6A5C8EB47868686AE386FBC1C";
  static const uint8_t binary_fingerprint[16]; // = {0x75,0x56,0x74,0xF6,0xA5,0xC8,0xEB,0x47,0x86,0x86,0x86,0xAE,0x38,0x6F,0xBC,0x1C};

  TPrimitiveTypeEntry() : type((TTypeId::type)0) {
  }

  virtual ~TPrimitiveTypeEntry() throw() {}

  TTypeId::type type;
  TTypeQualifiers typeQualifiers;

  _TPrimitiveTypeEntry__isset __isset;

  void __set_type(const TTypeId::type val) {
    type = val;
  }

  void __set_typeQualifiers(const TTypeQualifiers& val) {
    typeQualifiers = val;
    __isset.typeQualifiers = true;
  }

  bool operator == (const TPrimitiveTypeEntry & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.typeQualifiers != rhs.__isset.typeQualifiers)
      return false;
    else if (__isset.typeQualifiers && !(typeQualifiers == rhs.typeQualifiers))
      return false;
    return true;
  }
  bool operator != (const TPrimitiveTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrimitiveTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPrimitiveTypeEntry &a, TPrimitiveTypeEntry &b);


class TArrayTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  TArrayTypeEntry() : objectTypePtr(0) {
  }

  virtual ~TArrayTypeEntry() throw() {}

  TTypeEntryPtr objectTypePtr;

  void __set_objectTypePtr(const TTypeEntryPtr val) {
    objectTypePtr = val;
  }

  bool operator == (const TArrayTypeEntry & rhs) const
  {
    if (!(objectTypePtr == rhs.objectTypePtr))
      return false;
    return true;
  }
  bool operator != (const TArrayTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TArrayTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TArrayTypeEntry &a, TArrayTypeEntry &b);


class TMapTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  TMapTypeEntry() : keyTypePtr(0), valueTypePtr(0) {
  }

  virtual ~TMapTypeEntry() throw() {}

  TTypeEntryPtr keyTypePtr;
  TTypeEntryPtr valueTypePtr;

  void __set_keyTypePtr(const TTypeEntryPtr val) {
    keyTypePtr = val;
  }

  void __set_valueTypePtr(const TTypeEntryPtr val) {
    valueTypePtr = val;
  }

  bool operator == (const TMapTypeEntry & rhs) const
  {
    if (!(keyTypePtr == rhs.keyTypePtr))
      return false;
    if (!(valueTypePtr == rhs.valueTypePtr))
      return false;
    return true;
  }
  bool operator != (const TMapTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMapTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMapTypeEntry &a, TMapTypeEntry &b);


class TStructTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "91F548CA159B4AB4291F5741AC161402";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

  TStructTypeEntry() {
  }

  virtual ~TStructTypeEntry() throw() {}

  std::map<std::string, TTypeEntryPtr>  nameToTypePtr;

  void __set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
    nameToTypePtr = val;
  }

  bool operator == (const TStructTypeEntry & rhs) const
  {
    if (!(nameToTypePtr == rhs.nameToTypePtr))
      return false;
    return true;
  }
  bool operator != (const TStructTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStructTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStructTypeEntry &a, TStructTypeEntry &b);


class TUnionTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "91F548CA159B4AB4291F5741AC161402";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xF5,0x48,0xCA,0x15,0x9B,0x4A,0xB4,0x29,0x1F,0x57,0x41,0xAC,0x16,0x14,0x02};

  TUnionTypeEntry() {
  }

  virtual ~TUnionTypeEntry() throw() {}

  std::map<std::string, TTypeEntryPtr>  nameToTypePtr;

  void __set_nameToTypePtr(const std::map<std::string, TTypeEntryPtr> & val) {
    nameToTypePtr = val;
  }

  bool operator == (const TUnionTypeEntry & rhs) const
  {
    if (!(nameToTypePtr == rhs.nameToTypePtr))
      return false;
    return true;
  }
  bool operator != (const TUnionTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUnionTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUnionTypeEntry &a, TUnionTypeEntry &b);


class TUserDefinedTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TUserDefinedTypeEntry() : typeClassName() {
  }

  virtual ~TUserDefinedTypeEntry() throw() {}

  std::string typeClassName;

  void __set_typeClassName(const std::string& val) {
    typeClassName = val;
  }

  bool operator == (const TUserDefinedTypeEntry & rhs) const
  {
    if (!(typeClassName == rhs.typeClassName))
      return false;
    return true;
  }
  bool operator != (const TUserDefinedTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUserDefinedTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUserDefinedTypeEntry &a, TUserDefinedTypeEntry &b);

typedef struct _TTypeEntry__isset {
  _TTypeEntry__isset() : primitiveEntry(false), arrayEntry(false), mapEntry(false), structEntry(false), unionEntry(false), userDefinedTypeEntry(false) {}
  bool primitiveEntry;
  bool arrayEntry;
  bool mapEntry;
  bool structEntry;
  bool unionEntry;
  bool userDefinedTypeEntry;
} _TTypeEntry__isset;

class TTypeEntry {
 public:

  static const char* ascii_fingerprint; // = "2FE56D9097E325DAA7E933738C6D325F";
  static const uint8_t binary_fingerprint[16]; // = {0x2F,0xE5,0x6D,0x90,0x97,0xE3,0x25,0xDA,0xA7,0xE9,0x33,0x73,0x8C,0x6D,0x32,0x5F};

  TTypeEntry() {
  }

  virtual ~TTypeEntry() throw() {}

  TPrimitiveTypeEntry primitiveEntry;
  TArrayTypeEntry arrayEntry;
  TMapTypeEntry mapEntry;
  TStructTypeEntry structEntry;
  TUnionTypeEntry unionEntry;
  TUserDefinedTypeEntry userDefinedTypeEntry;

  _TTypeEntry__isset __isset;

  void __set_primitiveEntry(const TPrimitiveTypeEntry& val) {
    primitiveEntry = val;
  }

  void __set_arrayEntry(const TArrayTypeEntry& val) {
    arrayEntry = val;
  }

  void __set_mapEntry(const TMapTypeEntry& val) {
    mapEntry = val;
  }

  void __set_structEntry(const TStructTypeEntry& val) {
    structEntry = val;
  }

  void __set_unionEntry(const TUnionTypeEntry& val) {
    unionEntry = val;
  }

  void __set_userDefinedTypeEntry(const TUserDefinedTypeEntry& val) {
    userDefinedTypeEntry = val;
  }

  bool operator == (const TTypeEntry & rhs) const
  {
    if (!(primitiveEntry == rhs.primitiveEntry))
      return false;
    if (!(arrayEntry == rhs.arrayEntry))
      return false;
    if (!(mapEntry == rhs.mapEntry))
      return false;
    if (!(structEntry == rhs.structEntry))
      return false;
    if (!(unionEntry == rhs.unionEntry))
      return false;
    if (!(userDefinedTypeEntry == rhs.userDefinedTypeEntry))
      return false;
    return true;
  }
  bool operator != (const TTypeEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeEntry &a, TTypeEntry &b);


class TTypeDesc {
 public:

  static const char* ascii_fingerprint; // = "90B3C5A0B73419A84E85E0E48C452AA5";
  static const uint8_t binary_fingerprint[16]; // = {0x90,0xB3,0xC5,0xA0,0xB7,0x34,0x19,0xA8,0x4E,0x85,0xE0,0xE4,0x8C,0x45,0x2A,0xA5};

  TTypeDesc() {
  }

  virtual ~TTypeDesc() throw() {}

  std::vector<TTypeEntry>  types;

  void __set_types(const std::vector<TTypeEntry> & val) {
    types = val;
  }

  bool operator == (const TTypeDesc & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const TTypeDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTypeDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTypeDesc &a, TTypeDesc &b);

typedef struct _TColumnDesc__isset {
  _TColumnDesc__isset() : comment(false) {}
  bool comment;
} _TColumnDesc__isset;

class TColumnDesc {
 public:

  static const char* ascii_fingerprint; // = "EABED9009D5FCABFCA65612069F2A849";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xBE,0xD9,0x00,0x9D,0x5F,0xCA,0xBF,0xCA,0x65,0x61,0x20,0x69,0xF2,0xA8,0x49};

  TColumnDesc() : columnName(), position(0), comment() {
  }

  virtual ~TColumnDesc() throw() {}

  std::string columnName;
  TTypeDesc typeDesc;
  int32_t position;
  std::string comment;

  _TColumnDesc__isset __isset;

  void __set_columnName(const std::string& val) {
    columnName = val;
  }

  void __set_typeDesc(const TTypeDesc& val) {
    typeDesc = val;
  }

  void __set_position(const int32_t val) {
    position = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  bool operator == (const TColumnDesc & rhs) const
  {
    if (!(columnName == rhs.columnName))
      return false;
    if (!(typeDesc == rhs.typeDesc))
      return false;
    if (!(position == rhs.position))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const TColumnDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnDesc &a, TColumnDesc &b);


class TTableSchema {
 public:

  static const char* ascii_fingerprint; // = "7A1811E49313E5977107FC667B20E39D";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x18,0x11,0xE4,0x93,0x13,0xE5,0x97,0x71,0x07,0xFC,0x66,0x7B,0x20,0xE3,0x9D};

  TTableSchema() {
  }

  virtual ~TTableSchema() throw() {}

  std::vector<TColumnDesc>  columns;

  void __set_columns(const std::vector<TColumnDesc> & val) {
    columns = val;
  }

  bool operator == (const TTableSchema & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TTableSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableSchema &a, TTableSchema &b);

typedef struct _TBoolValue__isset {
  _TBoolValue__isset() : value(false) {}
  bool value;
} _TBoolValue__isset;

class TBoolValue {
 public:

  static const char* ascii_fingerprint; // = "BF054652DEF86253C2BEE7D947F167DD";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x05,0x46,0x52,0xDE,0xF8,0x62,0x53,0xC2,0xBE,0xE7,0xD9,0x47,0xF1,0x67,0xDD};

  TBoolValue() : value(0) {
  }

  virtual ~TBoolValue() throw() {}

  bool value;

  _TBoolValue__isset __isset;

  void __set_value(const bool val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TBoolValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBoolValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBoolValue &a, TBoolValue &b);

typedef struct _TByteValue__isset {
  _TByteValue__isset() : value(false) {}
  bool value;
} _TByteValue__isset;

class TByteValue {
 public:

  static const char* ascii_fingerprint; // = "9C15298ACB5D04AEA9B52D5DDE6F9208";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0x15,0x29,0x8A,0xCB,0x5D,0x04,0xAE,0xA9,0xB5,0x2D,0x5D,0xDE,0x6F,0x92,0x08};

  TByteValue() : value(0) {
  }

  virtual ~TByteValue() throw() {}

  int8_t value;

  _TByteValue__isset __isset;

  void __set_value(const int8_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TByteValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TByteValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TByteValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TByteValue &a, TByteValue &b);

typedef struct _TI16Value__isset {
  _TI16Value__isset() : value(false) {}
  bool value;
} _TI16Value__isset;

class TI16Value {
 public:

  static const char* ascii_fingerprint; // = "5DAC9C51C7E1106BF936FC71860BE9D5";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0xAC,0x9C,0x51,0xC7,0xE1,0x10,0x6B,0xF9,0x36,0xFC,0x71,0x86,0x0B,0xE9,0xD5};

  TI16Value() : value(0) {
  }

  virtual ~TI16Value() throw() {}

  int16_t value;

  _TI16Value__isset __isset;

  void __set_value(const int16_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TI16Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI16Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI16Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI16Value &a, TI16Value &b);

typedef struct _TI32Value__isset {
  _TI32Value__isset() : value(false) {}
  bool value;
} _TI32Value__isset;

class TI32Value {
 public:

  static const char* ascii_fingerprint; // = "E7A96B151330359E84C0A3AC91BCBACD";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0xA9,0x6B,0x15,0x13,0x30,0x35,0x9E,0x84,0xC0,0xA3,0xAC,0x91,0xBC,0xBA,0xCD};

  TI32Value() : value(0) {
  }

  virtual ~TI32Value() throw() {}

  int32_t value;

  _TI32Value__isset __isset;

  void __set_value(const int32_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TI32Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI32Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI32Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI32Value &a, TI32Value &b);

typedef struct _TI64Value__isset {
  _TI64Value__isset() : value(false) {}
  bool value;
} _TI64Value__isset;

class TI64Value {
 public:

  static const char* ascii_fingerprint; // = "148F3AAAC1D9859963D5E800D187BF26";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0x8F,0x3A,0xAA,0xC1,0xD9,0x85,0x99,0x63,0xD5,0xE8,0x00,0xD1,0x87,0xBF,0x26};

  TI64Value() : value(0) {
  }

  virtual ~TI64Value() throw() {}

  int64_t value;

  _TI64Value__isset __isset;

  void __set_value(const int64_t val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TI64Value & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TI64Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI64Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI64Value &a, TI64Value &b);

typedef struct _TDoubleValue__isset {
  _TDoubleValue__isset() : value(false) {}
  bool value;
} _TDoubleValue__isset;

class TDoubleValue {
 public:

  static const char* ascii_fingerprint; // = "3586E570A474C4A8603B4FF74903B3A6";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0x86,0xE5,0x70,0xA4,0x74,0xC4,0xA8,0x60,0x3B,0x4F,0xF7,0x49,0x03,0xB3,0xA6};

  TDoubleValue() : value(0) {
  }

  virtual ~TDoubleValue() throw() {}

  double value;

  _TDoubleValue__isset __isset;

  void __set_value(const double val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TDoubleValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TDoubleValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDoubleValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDoubleValue &a, TDoubleValue &b);

typedef struct _TStringValue__isset {
  _TStringValue__isset() : value(false) {}
  bool value;
} _TStringValue__isset;

class TStringValue {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TStringValue() : value() {
  }

  virtual ~TStringValue() throw() {}

  std::string value;

  _TStringValue__isset __isset;

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TStringValue & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TStringValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStringValue &a, TStringValue &b);

typedef struct _TColumnValue__isset {
  _TColumnValue__isset() : boolVal(false), byteVal(false), i16Val(false), i32Val(false), i64Val(false), doubleVal(false), stringVal(false) {}
  bool boolVal;
  bool byteVal;
  bool i16Val;
  bool i32Val;
  bool i64Val;
  bool doubleVal;
  bool stringVal;
} _TColumnValue__isset;

class TColumnValue {
 public:

  static const char* ascii_fingerprint; // = "C2DDD988447EA7999A8285AA38AAE9AD";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0xDD,0xD9,0x88,0x44,0x7E,0xA7,0x99,0x9A,0x82,0x85,0xAA,0x38,0xAA,0xE9,0xAD};

  TColumnValue() {
  }

  virtual ~TColumnValue() throw() {}

  TBoolValue boolVal;
  TByteValue byteVal;
  TI16Value i16Val;
  TI32Value i32Val;
  TI64Value i64Val;
  TDoubleValue doubleVal;
  TStringValue stringVal;

  _TColumnValue__isset __isset;

  void __set_boolVal(const TBoolValue& val) {
    boolVal = val;
  }

  void __set_byteVal(const TByteValue& val) {
    byteVal = val;
  }

  void __set_i16Val(const TI16Value& val) {
    i16Val = val;
  }

  void __set_i32Val(const TI32Value& val) {
    i32Val = val;
  }

  void __set_i64Val(const TI64Value& val) {
    i64Val = val;
  }

  void __set_doubleVal(const TDoubleValue& val) {
    doubleVal = val;
  }

  void __set_stringVal(const TStringValue& val) {
    stringVal = val;
  }

  bool operator == (const TColumnValue & rhs) const
  {
    if (!(boolVal == rhs.boolVal))
      return false;
    if (!(byteVal == rhs.byteVal))
      return false;
    if (!(i16Val == rhs.i16Val))
      return false;
    if (!(i32Val == rhs.i32Val))
      return false;
    if (!(i64Val == rhs.i64Val))
      return false;
    if (!(doubleVal == rhs.doubleVal))
      return false;
    if (!(stringVal == rhs.stringVal))
      return false;
    return true;
  }
  bool operator != (const TColumnValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnValue &a, TColumnValue &b);


class TRow {
 public:

  static const char* ascii_fingerprint; // = "E73FD1FCA0CA58A669FC3E02FB68D534";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x3F,0xD1,0xFC,0xA0,0xCA,0x58,0xA6,0x69,0xFC,0x3E,0x02,0xFB,0x68,0xD5,0x34};

  TRow() {
  }

  virtual ~TRow() throw() {}

  std::vector<TColumnValue>  colVals;

  void __set_colVals(const std::vector<TColumnValue> & val) {
    colVals = val;
  }

  bool operator == (const TRow & rhs) const
  {
    if (!(colVals == rhs.colVals))
      return false;
    return true;
  }
  bool operator != (const TRow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRow &a, TRow &b);


class TBoolColumn {
 public:

  static const char* ascii_fingerprint; // = "F9058324D96DB7F974D8ACDC01C54219";
  static const uint8_t binary_fingerprint[16]; // = {0xF9,0x05,0x83,0x24,0xD9,0x6D,0xB7,0xF9,0x74,0xD8,0xAC,0xDC,0x01,0xC5,0x42,0x19};

  TBoolColumn() : nulls() {
  }

  virtual ~TBoolColumn() throw() {}

  std::vector<bool>  values;
  std::string nulls;

  void __set_values(const std::vector<bool> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TBoolColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TBoolColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBoolColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBoolColumn &a, TBoolColumn &b);


class TByteColumn {
 public:

  static const char* ascii_fingerprint; // = "1CB300106BAA463A70BB2A2395900F48";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xB3,0x00,0x10,0x6B,0xAA,0x46,0x3A,0x70,0xBB,0x2A,0x23,0x95,0x90,0x0F,0x48};

  TByteColumn() : nulls() {
  }

  virtual ~TByteColumn() throw() {}

  std::vector<int8_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int8_t> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TByteColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TByteColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TByteColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TByteColumn &a, TByteColumn &b);


class TI16Column {
 public:

  static const char* ascii_fingerprint; // = "6574CDB1F121C8DB47FB257A3F104BDB";
  static const uint8_t binary_fingerprint[16]; // = {0x65,0x74,0xCD,0xB1,0xF1,0x21,0xC8,0xDB,0x47,0xFB,0x25,0x7A,0x3F,0x10,0x4B,0xDB};

  TI16Column() : nulls() {
  }

  virtual ~TI16Column() throw() {}

  std::vector<int16_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int16_t> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TI16Column & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TI16Column &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI16Column & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI16Column &a, TI16Column &b);


class TI32Column {
 public:

  static const char* ascii_fingerprint; // = "CCCCE89C7E9DA10280F5663700677313";
  static const uint8_t binary_fingerprint[16]; // = {0xCC,0xCC,0xE8,0x9C,0x7E,0x9D,0xA1,0x02,0x80,0xF5,0x66,0x37,0x00,0x67,0x73,0x13};

  TI32Column() : nulls() {
  }

  virtual ~TI32Column() throw() {}

  std::vector<int32_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int32_t> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TI32Column & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TI32Column &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI32Column & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI32Column &a, TI32Column &b);


class TI64Column {
 public:

  static const char* ascii_fingerprint; // = "925353917FC0AF87976A2338011F5A31";
  static const uint8_t binary_fingerprint[16]; // = {0x92,0x53,0x53,0x91,0x7F,0xC0,0xAF,0x87,0x97,0x6A,0x23,0x38,0x01,0x1F,0x5A,0x31};

  TI64Column() : nulls() {
  }

  virtual ~TI64Column() throw() {}

  std::vector<int64_t>  values;
  std::string nulls;

  void __set_values(const std::vector<int64_t> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TI64Column & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TI64Column &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TI64Column & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TI64Column &a, TI64Column &b);


class TDoubleColumn {
 public:

  static const char* ascii_fingerprint; // = "8FF1C050A8D7FD247AEB23CD71539C09";
  static const uint8_t binary_fingerprint[16]; // = {0x8F,0xF1,0xC0,0x50,0xA8,0xD7,0xFD,0x24,0x7A,0xEB,0x23,0xCD,0x71,0x53,0x9C,0x09};

  TDoubleColumn() : nulls() {
  }

  virtual ~TDoubleColumn() throw() {}

  std::vector<double>  values;
  std::string nulls;

  void __set_values(const std::vector<double> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TDoubleColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TDoubleColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDoubleColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDoubleColumn &a, TDoubleColumn &b);


class TStringColumn {
 public:

  static const char* ascii_fingerprint; // = "BE556BF7091B2DABBA1863D5E458B15F";
  static const uint8_t binary_fingerprint[16]; // = {0xBE,0x55,0x6B,0xF7,0x09,0x1B,0x2D,0xAB,0xBA,0x18,0x63,0xD5,0xE4,0x58,0xB1,0x5F};

  TStringColumn() : nulls() {
  }

  virtual ~TStringColumn() throw() {}

  std::vector<std::string>  values;
  std::string nulls;

  void __set_values(const std::vector<std::string> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TStringColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TStringColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStringColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStringColumn &a, TStringColumn &b);


class TBinaryColumn {
 public:

  static const char* ascii_fingerprint; // = "BE556BF7091B2DABBA1863D5E458B15F";
  static const uint8_t binary_fingerprint[16]; // = {0xBE,0x55,0x6B,0xF7,0x09,0x1B,0x2D,0xAB,0xBA,0x18,0x63,0xD5,0xE4,0x58,0xB1,0x5F};

  TBinaryColumn() : nulls() {
  }

  virtual ~TBinaryColumn() throw() {}

  std::vector<std::string>  values;
  std::string nulls;

  void __set_values(const std::vector<std::string> & val) {
    values = val;
  }

  void __set_nulls(const std::string& val) {
    nulls = val;
  }

  bool operator == (const TBinaryColumn & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(nulls == rhs.nulls))
      return false;
    return true;
  }
  bool operator != (const TBinaryColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBinaryColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBinaryColumn &a, TBinaryColumn &b);

typedef struct _TColumn__isset {
  _TColumn__isset() : boolVal(false), byteVal(false), i16Val(false), i32Val(false), i64Val(false), doubleVal(false), stringVal(false), binaryVal(false) {}
  bool boolVal;
  bool byteVal;
  bool i16Val;
  bool i32Val;
  bool i64Val;
  bool doubleVal;
  bool stringVal;
  bool binaryVal;
} _TColumn__isset;

class TColumn {
 public:

  static const char* ascii_fingerprint; // = "E6ADD10B4CDDE61A19E8878CC7039A17";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0xAD,0xD1,0x0B,0x4C,0xDD,0xE6,0x1A,0x19,0xE8,0x87,0x8C,0xC7,0x03,0x9A,0x17};

  TColumn() {
  }

  virtual ~TColumn() throw() {}

  TBoolColumn boolVal;
  TByteColumn byteVal;
  TI16Column i16Val;
  TI32Column i32Val;
  TI64Column i64Val;
  TDoubleColumn doubleVal;
  TStringColumn stringVal;
  TBinaryColumn binaryVal;

  _TColumn__isset __isset;

  void __set_boolVal(const TBoolColumn& val) {
    boolVal = val;
  }

  void __set_byteVal(const TByteColumn& val) {
    byteVal = val;
  }

  void __set_i16Val(const TI16Column& val) {
    i16Val = val;
  }

  void __set_i32Val(const TI32Column& val) {
    i32Val = val;
  }

  void __set_i64Val(const TI64Column& val) {
    i64Val = val;
  }

  void __set_doubleVal(const TDoubleColumn& val) {
    doubleVal = val;
  }

  void __set_stringVal(const TStringColumn& val) {
    stringVal = val;
  }

  void __set_binaryVal(const TBinaryColumn& val) {
    binaryVal = val;
  }

  bool operator == (const TColumn & rhs) const
  {
    if (!(boolVal == rhs.boolVal))
      return false;
    if (!(byteVal == rhs.byteVal))
      return false;
    if (!(i16Val == rhs.i16Val))
      return false;
    if (!(i32Val == rhs.i32Val))
      return false;
    if (!(i64Val == rhs.i64Val))
      return false;
    if (!(doubleVal == rhs.doubleVal))
      return false;
    if (!(stringVal == rhs.stringVal))
      return false;
    if (!(binaryVal == rhs.binaryVal))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumn &a, TColumn &b);

typedef struct _TRowSet__isset {
  _TRowSet__isset() : columns(false) {}
  bool columns;
} _TRowSet__isset;

class TRowSet {
 public:

  static const char* ascii_fingerprint; // = "46DA30A870489C7A58105AE0080DAEBF";
  static const uint8_t binary_fingerprint[16]; // = {0x46,0xDA,0x30,0xA8,0x70,0x48,0x9C,0x7A,0x58,0x10,0x5A,0xE0,0x08,0x0D,0xAE,0xBF};

  TRowSet() : startRowOffset(0) {
  }

  virtual ~TRowSet() throw() {}

  int64_t startRowOffset;
  std::vector<TRow>  rows;
  std::vector<TColumn>  columns;

  _TRowSet__isset __isset;

  void __set_startRowOffset(const int64_t val) {
    startRowOffset = val;
  }

  void __set_rows(const std::vector<TRow> & val) {
    rows = val;
  }

  void __set_columns(const std::vector<TColumn> & val) {
    columns = val;
    __isset.columns = true;
  }

  bool operator == (const TRowSet & rhs) const
  {
    if (!(startRowOffset == rhs.startRowOffset))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    return true;
  }
  bool operator != (const TRowSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRowSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRowSet &a, TRowSet &b);

typedef struct _TStatus__isset {
  _TStatus__isset() : infoMessages(false), sqlState(false), errorCode(false), errorMessage(false) {}
  bool infoMessages;
  bool sqlState;
  bool errorCode;
  bool errorMessage;
} _TStatus__isset;

class TStatus {
 public:

  static const char* ascii_fingerprint; // = "D5DEF49634A59C615C1B3A6F7D0DADB5";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xDE,0xF4,0x96,0x34,0xA5,0x9C,0x61,0x5C,0x1B,0x3A,0x6F,0x7D,0x0D,0xAD,0xB5};

  TStatus() : statusCode((TStatusCode::type)0), sqlState(), errorCode(0), errorMessage() {
  }

  virtual ~TStatus() throw() {}

  TStatusCode::type statusCode;
  std::vector<std::string>  infoMessages;
  std::string sqlState;
  int32_t errorCode;
  std::string errorMessage;

  _TStatus__isset __isset;

  void __set_statusCode(const TStatusCode::type val) {
    statusCode = val;
  }

  void __set_infoMessages(const std::vector<std::string> & val) {
    infoMessages = val;
    __isset.infoMessages = true;
  }

  void __set_sqlState(const std::string& val) {
    sqlState = val;
    __isset.sqlState = true;
  }

  void __set_errorCode(const int32_t val) {
    errorCode = val;
    __isset.errorCode = true;
  }

  void __set_errorMessage(const std::string& val) {
    errorMessage = val;
    __isset.errorMessage = true;
  }

  bool operator == (const TStatus & rhs) const
  {
    if (!(statusCode == rhs.statusCode))
      return false;
    if (__isset.infoMessages != rhs.__isset.infoMessages)
      return false;
    else if (__isset.infoMessages && !(infoMessages == rhs.infoMessages))
      return false;
    if (__isset.sqlState != rhs.__isset.sqlState)
      return false;
    else if (__isset.sqlState && !(sqlState == rhs.sqlState))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const TStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TStatus &a, TStatus &b);


class THandleIdentifier {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  THandleIdentifier() : guid(), secret() {
  }

  virtual ~THandleIdentifier() throw() {}

  std::string guid;
  std::string secret;

  void __set_guid(const std::string& val) {
    guid = val;
  }

  void __set_secret(const std::string& val) {
    secret = val;
  }

  bool operator == (const THandleIdentifier & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (!(secret == rhs.secret))
      return false;
    return true;
  }
  bool operator != (const THandleIdentifier &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THandleIdentifier & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THandleIdentifier &a, THandleIdentifier &b);


class TSessionHandle {
 public:

  static const char* ascii_fingerprint; // = "A756D3DBE614FB13F70BF7F7B6EB3D73";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

  TSessionHandle() {
  }

  virtual ~TSessionHandle() throw() {}

  THandleIdentifier sessionId;

  void __set_sessionId(const THandleIdentifier& val) {
    sessionId = val;
  }

  bool operator == (const TSessionHandle & rhs) const
  {
    if (!(sessionId == rhs.sessionId))
      return false;
    return true;
  }
  bool operator != (const TSessionHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSessionHandle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSessionHandle &a, TSessionHandle &b);

typedef struct _TOperationHandle__isset {
  _TOperationHandle__isset() : modifiedRowCount(false) {}
  bool modifiedRowCount;
} _TOperationHandle__isset;

class TOperationHandle {
 public:

  static const char* ascii_fingerprint; // = "29FD80F4F96804A30FCC59C23D2E5349";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0xFD,0x80,0xF4,0xF9,0x68,0x04,0xA3,0x0F,0xCC,0x59,0xC2,0x3D,0x2E,0x53,0x49};

  TOperationHandle() : operationType((TOperationType::type)0), hasResultSet(0), modifiedRowCount(0) {
  }

  virtual ~TOperationHandle() throw() {}

  THandleIdentifier operationId;
  TOperationType::type operationType;
  bool hasResultSet;
  double modifiedRowCount;

  _TOperationHandle__isset __isset;

  void __set_operationId(const THandleIdentifier& val) {
    operationId = val;
  }

  void __set_operationType(const TOperationType::type val) {
    operationType = val;
  }

  void __set_hasResultSet(const bool val) {
    hasResultSet = val;
  }

  void __set_modifiedRowCount(const double val) {
    modifiedRowCount = val;
    __isset.modifiedRowCount = true;
  }

  bool operator == (const TOperationHandle & rhs) const
  {
    if (!(operationId == rhs.operationId))
      return false;
    if (!(operationType == rhs.operationType))
      return false;
    if (!(hasResultSet == rhs.hasResultSet))
      return false;
    if (__isset.modifiedRowCount != rhs.__isset.modifiedRowCount)
      return false;
    else if (__isset.modifiedRowCount && !(modifiedRowCount == rhs.modifiedRowCount))
      return false;
    return true;
  }
  bool operator != (const TOperationHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOperationHandle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOperationHandle &a, TOperationHandle &b);

typedef struct _TOpenSessionReq__isset {
  _TOpenSessionReq__isset() : username(false), password(false), configuration(false) {}
  bool username;
  bool password;
  bool configuration;
} _TOpenSessionReq__isset;

class TOpenSessionReq {
 public:

  static const char* ascii_fingerprint; // = "C8FD0F306A16C16BDA7B57F58BFAE5B2";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0xFD,0x0F,0x30,0x6A,0x16,0xC1,0x6B,0xDA,0x7B,0x57,0xF5,0x8B,0xFA,0xE5,0xB2};

  TOpenSessionReq() : client_protocol((TProtocolVersion::type)7), username(), password() {
    client_protocol = (TProtocolVersion::type)7;

  }

  virtual ~TOpenSessionReq() throw() {}

  TProtocolVersion::type client_protocol;
  std::string username;
  std::string password;
  std::map<std::string, std::string>  configuration;

  _TOpenSessionReq__isset __isset;

  void __set_client_protocol(const TProtocolVersion::type val) {
    client_protocol = val;
  }

  void __set_username(const std::string& val) {
    username = val;
    __isset.username = true;
  }

  void __set_password(const std::string& val) {
    password = val;
    __isset.password = true;
  }

  void __set_configuration(const std::map<std::string, std::string> & val) {
    configuration = val;
    __isset.configuration = true;
  }

  bool operator == (const TOpenSessionReq & rhs) const
  {
    if (!(client_protocol == rhs.client_protocol))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TOpenSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOpenSessionReq &a, TOpenSessionReq &b);

typedef struct _TOpenSessionResp__isset {
  _TOpenSessionResp__isset() : sessionHandle(false), configuration(false) {}
  bool sessionHandle;
  bool configuration;
} _TOpenSessionResp__isset;

class TOpenSessionResp {
 public:

  static const char* ascii_fingerprint; // = "CFE7D7F4E9EC671F2518ED74FEE9F163";
  static const uint8_t binary_fingerprint[16]; // = {0xCF,0xE7,0xD7,0xF4,0xE9,0xEC,0x67,0x1F,0x25,0x18,0xED,0x74,0xFE,0xE9,0xF1,0x63};

  TOpenSessionResp() : serverProtocolVersion((TProtocolVersion::type)7) {
    serverProtocolVersion = (TProtocolVersion::type)7;

  }

  virtual ~TOpenSessionResp() throw() {}

  TStatus status;
  TProtocolVersion::type serverProtocolVersion;
  TSessionHandle sessionHandle;
  std::map<std::string, std::string>  configuration;

  _TOpenSessionResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_serverProtocolVersion(const TProtocolVersion::type val) {
    serverProtocolVersion = val;
  }

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
    __isset.sessionHandle = true;
  }

  void __set_configuration(const std::map<std::string, std::string> & val) {
    configuration = val;
    __isset.configuration = true;
  }

  bool operator == (const TOpenSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(serverProtocolVersion == rhs.serverProtocolVersion))
      return false;
    if (__isset.sessionHandle != rhs.__isset.sessionHandle)
      return false;
    else if (__isset.sessionHandle && !(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.configuration != rhs.__isset.configuration)
      return false;
    else if (__isset.configuration && !(configuration == rhs.configuration))
      return false;
    return true;
  }
  bool operator != (const TOpenSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOpenSessionResp &a, TOpenSessionResp &b);


class TCloseSessionReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TCloseSessionReq() {
  }

  virtual ~TCloseSessionReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TCloseSessionReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TCloseSessionReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseSessionReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseSessionReq &a, TCloseSessionReq &b);


class TCloseSessionResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCloseSessionResp() {
  }

  virtual ~TCloseSessionResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCloseSessionResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseSessionResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseSessionResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseSessionResp &a, TCloseSessionResp &b);

typedef struct _TGetInfoValue__isset {
  _TGetInfoValue__isset() : stringValue(false), smallIntValue(false), integerBitmask(false), integerFlag(false), binaryValue(false), lenValue(false) {}
  bool stringValue;
  bool smallIntValue;
  bool integerBitmask;
  bool integerFlag;
  bool binaryValue;
  bool lenValue;
} _TGetInfoValue__isset;

class TGetInfoValue {
 public:

  static const char* ascii_fingerprint; // = "057FED11279FD7248CFE73EE82ED579E";
  static const uint8_t binary_fingerprint[16]; // = {0x05,0x7F,0xED,0x11,0x27,0x9F,0xD7,0x24,0x8C,0xFE,0x73,0xEE,0x82,0xED,0x57,0x9E};

  TGetInfoValue() : stringValue(), smallIntValue(0), integerBitmask(0), integerFlag(0), binaryValue(0), lenValue(0) {
  }

  virtual ~TGetInfoValue() throw() {}

  std::string stringValue;
  int16_t smallIntValue;
  int32_t integerBitmask;
  int32_t integerFlag;
  int32_t binaryValue;
  int64_t lenValue;

  _TGetInfoValue__isset __isset;

  void __set_stringValue(const std::string& val) {
    stringValue = val;
  }

  void __set_smallIntValue(const int16_t val) {
    smallIntValue = val;
  }

  void __set_integerBitmask(const int32_t val) {
    integerBitmask = val;
  }

  void __set_integerFlag(const int32_t val) {
    integerFlag = val;
  }

  void __set_binaryValue(const int32_t val) {
    binaryValue = val;
  }

  void __set_lenValue(const int64_t val) {
    lenValue = val;
  }

  bool operator == (const TGetInfoValue & rhs) const
  {
    if (!(stringValue == rhs.stringValue))
      return false;
    if (!(smallIntValue == rhs.smallIntValue))
      return false;
    if (!(integerBitmask == rhs.integerBitmask))
      return false;
    if (!(integerFlag == rhs.integerFlag))
      return false;
    if (!(binaryValue == rhs.binaryValue))
      return false;
    if (!(lenValue == rhs.lenValue))
      return false;
    return true;
  }
  bool operator != (const TGetInfoValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetInfoValue &a, TGetInfoValue &b);


class TGetInfoReq {
 public:

  static const char* ascii_fingerprint; // = "95675B1A0BADE5F7EDE323809DB679B2";
  static const uint8_t binary_fingerprint[16]; // = {0x95,0x67,0x5B,0x1A,0x0B,0xAD,0xE5,0xF7,0xED,0xE3,0x23,0x80,0x9D,0xB6,0x79,0xB2};

  TGetInfoReq() : infoType((TGetInfoType::type)0) {
  }

  virtual ~TGetInfoReq() throw() {}

  TSessionHandle sessionHandle;
  TGetInfoType::type infoType;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_infoType(const TGetInfoType::type val) {
    infoType = val;
  }

  bool operator == (const TGetInfoReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(infoType == rhs.infoType))
      return false;
    return true;
  }
  bool operator != (const TGetInfoReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetInfoReq &a, TGetInfoReq &b);


class TGetInfoResp {
 public:

  static const char* ascii_fingerprint; // = "72AFA10A82728B51FDE91092012868DE";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0xAF,0xA1,0x0A,0x82,0x72,0x8B,0x51,0xFD,0xE9,0x10,0x92,0x01,0x28,0x68,0xDE};

  TGetInfoResp() {
  }

  virtual ~TGetInfoResp() throw() {}

  TStatus status;
  TGetInfoValue infoValue;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_infoValue(const TGetInfoValue& val) {
    infoValue = val;
  }

  bool operator == (const TGetInfoResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(infoValue == rhs.infoValue))
      return false;
    return true;
  }
  bool operator != (const TGetInfoResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetInfoResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetInfoResp &a, TGetInfoResp &b);

typedef struct _TExecuteStatementReq__isset {
  _TExecuteStatementReq__isset() : confOverlay(false), runAsync(true) {}
  bool confOverlay;
  bool runAsync;
} _TExecuteStatementReq__isset;

class TExecuteStatementReq {
 public:

  static const char* ascii_fingerprint; // = "FED75DB77E66D76EC1939A51FB0D96FA";
  static const uint8_t binary_fingerprint[16]; // = {0xFE,0xD7,0x5D,0xB7,0x7E,0x66,0xD7,0x6E,0xC1,0x93,0x9A,0x51,0xFB,0x0D,0x96,0xFA};

  TExecuteStatementReq() : statement(), runAsync(false) {
  }

  virtual ~TExecuteStatementReq() throw() {}

  TSessionHandle sessionHandle;
  std::string statement;
  std::map<std::string, std::string>  confOverlay;
  bool runAsync;

  _TExecuteStatementReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_statement(const std::string& val) {
    statement = val;
  }

  void __set_confOverlay(const std::map<std::string, std::string> & val) {
    confOverlay = val;
    __isset.confOverlay = true;
  }

  void __set_runAsync(const bool val) {
    runAsync = val;
    __isset.runAsync = true;
  }

  bool operator == (const TExecuteStatementReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(statement == rhs.statement))
      return false;
    if (__isset.confOverlay != rhs.__isset.confOverlay)
      return false;
    else if (__isset.confOverlay && !(confOverlay == rhs.confOverlay))
      return false;
    if (__isset.runAsync != rhs.__isset.runAsync)
      return false;
    else if (__isset.runAsync && !(runAsync == rhs.runAsync))
      return false;
    return true;
  }
  bool operator != (const TExecuteStatementReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecuteStatementReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecuteStatementReq &a, TExecuteStatementReq &b);

typedef struct _TExecuteStatementResp__isset {
  _TExecuteStatementResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TExecuteStatementResp__isset;

class TExecuteStatementResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TExecuteStatementResp() {
  }

  virtual ~TExecuteStatementResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TExecuteStatementResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TExecuteStatementResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TExecuteStatementResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecuteStatementResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecuteStatementResp &a, TExecuteStatementResp &b);


class TGetTypeInfoReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TGetTypeInfoReq() {
  }

  virtual ~TGetTypeInfoReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TGetTypeInfoReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTypeInfoReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTypeInfoReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTypeInfoReq &a, TGetTypeInfoReq &b);

typedef struct _TGetTypeInfoResp__isset {
  _TGetTypeInfoResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetTypeInfoResp__isset;

class TGetTypeInfoResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetTypeInfoResp() {
  }

  virtual ~TGetTypeInfoResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetTypeInfoResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetTypeInfoResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTypeInfoResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTypeInfoResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTypeInfoResp &a, TGetTypeInfoResp &b);


class TGetCatalogsReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TGetCatalogsReq() {
  }

  virtual ~TGetCatalogsReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TGetCatalogsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCatalogsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCatalogsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetCatalogsReq &a, TGetCatalogsReq &b);

typedef struct _TGetCatalogsResp__isset {
  _TGetCatalogsResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetCatalogsResp__isset;

class TGetCatalogsResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetCatalogsResp() {
  }

  virtual ~TGetCatalogsResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetCatalogsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetCatalogsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetCatalogsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetCatalogsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetCatalogsResp &a, TGetCatalogsResp &b);

typedef struct _TGetSchemasReq__isset {
  _TGetSchemasReq__isset() : catalogName(false), schemaName(false) {}
  bool catalogName;
  bool schemaName;
} _TGetSchemasReq__isset;

class TGetSchemasReq {
 public:

  static const char* ascii_fingerprint; // = "28A9D12DE8393DD3E73FC1E5AE6E113B";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xA9,0xD1,0x2D,0xE8,0x39,0x3D,0xD3,0xE7,0x3F,0xC1,0xE5,0xAE,0x6E,0x11,0x3B};

  TGetSchemasReq() : catalogName(), schemaName() {
  }

  virtual ~TGetSchemasReq() throw() {}

  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;

  _TGetSchemasReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  bool operator == (const TGetSchemasReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    return true;
  }
  bool operator != (const TGetSchemasReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetSchemasReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetSchemasReq &a, TGetSchemasReq &b);

typedef struct _TGetSchemasResp__isset {
  _TGetSchemasResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetSchemasResp__isset;

class TGetSchemasResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetSchemasResp() {
  }

  virtual ~TGetSchemasResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetSchemasResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetSchemasResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetSchemasResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetSchemasResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetSchemasResp &a, TGetSchemasResp &b);

typedef struct _TGetTablesReq__isset {
  _TGetTablesReq__isset() : catalogName(false), schemaName(false), tableName(false), tableTypes(false) {}
  bool catalogName;
  bool schemaName;
  bool tableName;
  bool tableTypes;
} _TGetTablesReq__isset;

class TGetTablesReq {
 public:

  static const char* ascii_fingerprint; // = "C80DFEE06850052F5A445BE81ED763DB";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x0D,0xFE,0xE0,0x68,0x50,0x05,0x2F,0x5A,0x44,0x5B,0xE8,0x1E,0xD7,0x63,0xDB};

  TGetTablesReq() : catalogName(), schemaName(), tableName() {
  }

  virtual ~TGetTablesReq() throw() {}

  TSessionHandle sessionHandle;
  TPatternOrIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier tableName;
  std::vector<std::string>  tableTypes;

  _TGetTablesReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TPatternOrIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  void __set_tableName(const TPatternOrIdentifier& val) {
    tableName = val;
    __isset.tableName = true;
  }

  void __set_tableTypes(const std::vector<std::string> & val) {
    tableTypes = val;
    __isset.tableTypes = true;
  }

  bool operator == (const TGetTablesReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.tableTypes != rhs.__isset.tableTypes)
      return false;
    else if (__isset.tableTypes && !(tableTypes == rhs.tableTypes))
      return false;
    return true;
  }
  bool operator != (const TGetTablesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesReq &a, TGetTablesReq &b);

typedef struct _TGetTablesResp__isset {
  _TGetTablesResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetTablesResp__isset;

class TGetTablesResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetTablesResp() {
  }

  virtual ~TGetTablesResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetTablesResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetTablesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTablesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesResp &a, TGetTablesResp &b);


class TGetTableTypesReq {
 public:

  static const char* ascii_fingerprint; // = "82377107F8BD0526960537D5A112E6EF";
  static const uint8_t binary_fingerprint[16]; // = {0x82,0x37,0x71,0x07,0xF8,0xBD,0x05,0x26,0x96,0x05,0x37,0xD5,0xA1,0x12,0xE6,0xEF};

  TGetTableTypesReq() {
  }

  virtual ~TGetTableTypesReq() throw() {}

  TSessionHandle sessionHandle;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  bool operator == (const TGetTableTypesReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTableTypesReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTableTypesReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTableTypesReq &a, TGetTableTypesReq &b);

typedef struct _TGetTableTypesResp__isset {
  _TGetTableTypesResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetTableTypesResp__isset;

class TGetTableTypesResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetTableTypesResp() {
  }

  virtual ~TGetTableTypesResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetTableTypesResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetTableTypesResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetTableTypesResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTableTypesResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTableTypesResp &a, TGetTableTypesResp &b);

typedef struct _TGetColumnsReq__isset {
  _TGetColumnsReq__isset() : catalogName(false), schemaName(false), tableName(false), columnName(false) {}
  bool catalogName;
  bool schemaName;
  bool tableName;
  bool columnName;
} _TGetColumnsReq__isset;

class TGetColumnsReq {
 public:

  static const char* ascii_fingerprint; // = "72D0F28ED33A49B7306DF63EEE956C28";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0xD0,0xF2,0x8E,0xD3,0x3A,0x49,0xB7,0x30,0x6D,0xF6,0x3E,0xEE,0x95,0x6C,0x28};

  TGetColumnsReq() : catalogName(), schemaName(), tableName(), columnName() {
  }

  virtual ~TGetColumnsReq() throw() {}

  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier tableName;
  TPatternOrIdentifier columnName;

  _TGetColumnsReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  void __set_tableName(const TPatternOrIdentifier& val) {
    tableName = val;
    __isset.tableName = true;
  }

  void __set_columnName(const TPatternOrIdentifier& val) {
    columnName = val;
    __isset.columnName = true;
  }

  bool operator == (const TGetColumnsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (__isset.tableName != rhs.__isset.tableName)
      return false;
    else if (__isset.tableName && !(tableName == rhs.tableName))
      return false;
    if (__isset.columnName != rhs.__isset.columnName)
      return false;
    else if (__isset.columnName && !(columnName == rhs.columnName))
      return false;
    return true;
  }
  bool operator != (const TGetColumnsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetColumnsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetColumnsReq &a, TGetColumnsReq &b);

typedef struct _TGetColumnsResp__isset {
  _TGetColumnsResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetColumnsResp__isset;

class TGetColumnsResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetColumnsResp() {
  }

  virtual ~TGetColumnsResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetColumnsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetColumnsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetColumnsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetColumnsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetColumnsResp &a, TGetColumnsResp &b);

typedef struct _TGetFunctionsReq__isset {
  _TGetFunctionsReq__isset() : catalogName(false), schemaName(false) {}
  bool catalogName;
  bool schemaName;
} _TGetFunctionsReq__isset;

class TGetFunctionsReq {
 public:

  static const char* ascii_fingerprint; // = "0887E0916ADE4521BF6017B534493138";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0x87,0xE0,0x91,0x6A,0xDE,0x45,0x21,0xBF,0x60,0x17,0xB5,0x34,0x49,0x31,0x38};

  TGetFunctionsReq() : catalogName(), schemaName(), functionName() {
  }

  virtual ~TGetFunctionsReq() throw() {}

  TSessionHandle sessionHandle;
  TIdentifier catalogName;
  TPatternOrIdentifier schemaName;
  TPatternOrIdentifier functionName;

  _TGetFunctionsReq__isset __isset;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_catalogName(const TIdentifier& val) {
    catalogName = val;
    __isset.catalogName = true;
  }

  void __set_schemaName(const TPatternOrIdentifier& val) {
    schemaName = val;
    __isset.schemaName = true;
  }

  void __set_functionName(const TPatternOrIdentifier& val) {
    functionName = val;
  }

  bool operator == (const TGetFunctionsReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (__isset.catalogName != rhs.__isset.catalogName)
      return false;
    else if (__isset.catalogName && !(catalogName == rhs.catalogName))
      return false;
    if (__isset.schemaName != rhs.__isset.schemaName)
      return false;
    else if (__isset.schemaName && !(schemaName == rhs.schemaName))
      return false;
    if (!(functionName == rhs.functionName))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetFunctionsReq &a, TGetFunctionsReq &b);

typedef struct _TGetFunctionsResp__isset {
  _TGetFunctionsResp__isset() : operationHandle(false) {}
  bool operationHandle;
} _TGetFunctionsResp__isset;

class TGetFunctionsResp {
 public:

  static const char* ascii_fingerprint; // = "02A075A0FF88D3A172916D8F23C7B286";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0xA0,0x75,0xA0,0xFF,0x88,0xD3,0xA1,0x72,0x91,0x6D,0x8F,0x23,0xC7,0xB2,0x86};

  TGetFunctionsResp() {
  }

  virtual ~TGetFunctionsResp() throw() {}

  TStatus status;
  TOperationHandle operationHandle;

  _TGetFunctionsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
    __isset.operationHandle = true;
  }

  bool operator == (const TGetFunctionsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationHandle != rhs.__isset.operationHandle)
      return false;
    else if (__isset.operationHandle && !(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetFunctionsResp &a, TGetFunctionsResp &b);


class TGetOperationStatusReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TGetOperationStatusReq() {
  }

  virtual ~TGetOperationStatusReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TGetOperationStatusReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetOperationStatusReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetOperationStatusReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetOperationStatusReq &a, TGetOperationStatusReq &b);

typedef struct _TGetOperationStatusResp__isset {
  _TGetOperationStatusResp__isset() : operationState(false), sqlState(false), errorCode(false), errorMessage(false) {}
  bool operationState;
  bool sqlState;
  bool errorCode;
  bool errorMessage;
} _TGetOperationStatusResp__isset;

class TGetOperationStatusResp {
 public:

  static const char* ascii_fingerprint; // = "BD124DB87A5A2E7D11945BD1B17F013D";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0x12,0x4D,0xB8,0x7A,0x5A,0x2E,0x7D,0x11,0x94,0x5B,0xD1,0xB1,0x7F,0x01,0x3D};

  TGetOperationStatusResp() : operationState((TOperationState::type)0), sqlState(), errorCode(0), errorMessage() {
  }

  virtual ~TGetOperationStatusResp() throw() {}

  TStatus status;
  TOperationState::type operationState;
  std::string sqlState;
  int32_t errorCode;
  std::string errorMessage;

  _TGetOperationStatusResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_operationState(const TOperationState::type val) {
    operationState = val;
    __isset.operationState = true;
  }

  void __set_sqlState(const std::string& val) {
    sqlState = val;
    __isset.sqlState = true;
  }

  void __set_errorCode(const int32_t val) {
    errorCode = val;
    __isset.errorCode = true;
  }

  void __set_errorMessage(const std::string& val) {
    errorMessage = val;
    __isset.errorMessage = true;
  }

  bool operator == (const TGetOperationStatusResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.operationState != rhs.__isset.operationState)
      return false;
    else if (__isset.operationState && !(operationState == rhs.operationState))
      return false;
    if (__isset.sqlState != rhs.__isset.sqlState)
      return false;
    else if (__isset.sqlState && !(sqlState == rhs.sqlState))
      return false;
    if (__isset.errorCode != rhs.__isset.errorCode)
      return false;
    else if (__isset.errorCode && !(errorCode == rhs.errorCode))
      return false;
    if (__isset.errorMessage != rhs.__isset.errorMessage)
      return false;
    else if (__isset.errorMessage && !(errorMessage == rhs.errorMessage))
      return false;
    return true;
  }
  bool operator != (const TGetOperationStatusResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetOperationStatusResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetOperationStatusResp &a, TGetOperationStatusResp &b);


class TCancelOperationReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TCancelOperationReq() {
  }

  virtual ~TCancelOperationReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TCancelOperationReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TCancelOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelOperationReq &a, TCancelOperationReq &b);


class TCancelOperationResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCancelOperationResp() {
  }

  virtual ~TCancelOperationResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCancelOperationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelOperationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelOperationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelOperationResp &a, TCancelOperationResp &b);


class TCloseOperationReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TCloseOperationReq() {
  }

  virtual ~TCloseOperationReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TCloseOperationReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TCloseOperationReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseOperationReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseOperationReq &a, TCloseOperationReq &b);


class TCloseOperationResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCloseOperationResp() {
  }

  virtual ~TCloseOperationResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCloseOperationResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseOperationResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseOperationResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseOperationResp &a, TCloseOperationResp &b);


class TGetResultSetMetadataReq {
 public:

  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};

  TGetResultSetMetadataReq() {
  }

  virtual ~TGetResultSetMetadataReq() throw() {}

  TOperationHandle operationHandle;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  bool operator == (const TGetResultSetMetadataReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    return true;
  }
  bool operator != (const TGetResultSetMetadataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetResultSetMetadataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetResultSetMetadataReq &a, TGetResultSetMetadataReq &b);

typedef struct _TGetResultSetMetadataResp__isset {
  _TGetResultSetMetadataResp__isset() : schema(false) {}
  bool schema;
} _TGetResultSetMetadataResp__isset;

class TGetResultSetMetadataResp {
 public:

  static const char* ascii_fingerprint; // = "42CD49B7F49CC1B6D4E6F5FA2D7BE812";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0xCD,0x49,0xB7,0xF4,0x9C,0xC1,0xB6,0xD4,0xE6,0xF5,0xFA,0x2D,0x7B,0xE8,0x12};

  TGetResultSetMetadataResp() {
  }

  virtual ~TGetResultSetMetadataResp() throw() {}

  TStatus status;
  TTableSchema schema;

  _TGetResultSetMetadataResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_schema(const TTableSchema& val) {
    schema = val;
    __isset.schema = true;
  }

  bool operator == (const TGetResultSetMetadataResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.schema != rhs.__isset.schema)
      return false;
    else if (__isset.schema && !(schema == rhs.schema))
      return false;
    return true;
  }
  bool operator != (const TGetResultSetMetadataResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetResultSetMetadataResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetResultSetMetadataResp &a, TGetResultSetMetadataResp &b);

typedef struct _TFetchResultsReq__isset {
  _TFetchResultsReq__isset() : fetchType(true) {}
  bool fetchType;
} _TFetchResultsReq__isset;

class TFetchResultsReq {
 public:

  static const char* ascii_fingerprint; // = "B4CB1E4F8F8F4D50183DD372AD11753A";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0xCB,0x1E,0x4F,0x8F,0x8F,0x4D,0x50,0x18,0x3D,0xD3,0x72,0xAD,0x11,0x75,0x3A};

  TFetchResultsReq() : orientation((TFetchOrientation::type)0), maxRows(0), fetchType(0) {
    orientation = (TFetchOrientation::type)0;

  }

  virtual ~TFetchResultsReq() throw() {}

  TOperationHandle operationHandle;
  TFetchOrientation::type orientation;
  int64_t maxRows;
  int16_t fetchType;

  _TFetchResultsReq__isset __isset;

  void __set_operationHandle(const TOperationHandle& val) {
    operationHandle = val;
  }

  void __set_orientation(const TFetchOrientation::type val) {
    orientation = val;
  }

  void __set_maxRows(const int64_t val) {
    maxRows = val;
  }

  void __set_fetchType(const int16_t val) {
    fetchType = val;
    __isset.fetchType = true;
  }

  bool operator == (const TFetchResultsReq & rhs) const
  {
    if (!(operationHandle == rhs.operationHandle))
      return false;
    if (!(orientation == rhs.orientation))
      return false;
    if (!(maxRows == rhs.maxRows))
      return false;
    if (__isset.fetchType != rhs.__isset.fetchType)
      return false;
    else if (__isset.fetchType && !(fetchType == rhs.fetchType))
      return false;
    return true;
  }
  bool operator != (const TFetchResultsReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResultsReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchResultsReq &a, TFetchResultsReq &b);

typedef struct _TFetchResultsResp__isset {
  _TFetchResultsResp__isset() : hasMoreRows(false), results(false) {}
  bool hasMoreRows;
  bool results;
} _TFetchResultsResp__isset;

class TFetchResultsResp {
 public:

  static const char* ascii_fingerprint; // = "FC43BC2D6F3B76D4DB0F34226A745C8E";
  static const uint8_t binary_fingerprint[16]; // = {0xFC,0x43,0xBC,0x2D,0x6F,0x3B,0x76,0xD4,0xDB,0x0F,0x34,0x22,0x6A,0x74,0x5C,0x8E};

  TFetchResultsResp() : hasMoreRows(0) {
  }

  virtual ~TFetchResultsResp() throw() {}

  TStatus status;
  bool hasMoreRows;
  TRowSet results;

  _TFetchResultsResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_hasMoreRows(const bool val) {
    hasMoreRows = val;
    __isset.hasMoreRows = true;
  }

  void __set_results(const TRowSet& val) {
    results = val;
    __isset.results = true;
  }

  bool operator == (const TFetchResultsResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.hasMoreRows != rhs.__isset.hasMoreRows)
      return false;
    else if (__isset.hasMoreRows && !(hasMoreRows == rhs.hasMoreRows))
      return false;
    if (__isset.results != rhs.__isset.results)
      return false;
    else if (__isset.results && !(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TFetchResultsResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFetchResultsResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFetchResultsResp &a, TFetchResultsResp &b);


class TGetDelegationTokenReq {
 public:

  static const char* ascii_fingerprint; // = "07EA0311716A27924914E4354ED22D6C";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xEA,0x03,0x11,0x71,0x6A,0x27,0x92,0x49,0x14,0xE4,0x35,0x4E,0xD2,0x2D,0x6C};

  TGetDelegationTokenReq() : owner(), renewer() {
  }

  virtual ~TGetDelegationTokenReq() throw() {}

  TSessionHandle sessionHandle;
  std::string owner;
  std::string renewer;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_renewer(const std::string& val) {
    renewer = val;
  }

  bool operator == (const TGetDelegationTokenReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(renewer == rhs.renewer))
      return false;
    return true;
  }
  bool operator != (const TGetDelegationTokenReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDelegationTokenReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDelegationTokenReq &a, TGetDelegationTokenReq &b);

typedef struct _TGetDelegationTokenResp__isset {
  _TGetDelegationTokenResp__isset() : delegationToken(false) {}
  bool delegationToken;
} _TGetDelegationTokenResp__isset;

class TGetDelegationTokenResp {
 public:

  static const char* ascii_fingerprint; // = "C0E132DC412CEA08D771EAC38CEA1DA6";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0xE1,0x32,0xDC,0x41,0x2C,0xEA,0x08,0xD7,0x71,0xEA,0xC3,0x8C,0xEA,0x1D,0xA6};

  TGetDelegationTokenResp() : delegationToken() {
  }

  virtual ~TGetDelegationTokenResp() throw() {}

  TStatus status;
  std::string delegationToken;

  _TGetDelegationTokenResp__isset __isset;

  void __set_status(const TStatus& val) {
    status = val;
  }

  void __set_delegationToken(const std::string& val) {
    delegationToken = val;
    __isset.delegationToken = true;
  }

  bool operator == (const TGetDelegationTokenResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.delegationToken != rhs.__isset.delegationToken)
      return false;
    else if (__isset.delegationToken && !(delegationToken == rhs.delegationToken))
      return false;
    return true;
  }
  bool operator != (const TGetDelegationTokenResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDelegationTokenResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDelegationTokenResp &a, TGetDelegationTokenResp &b);


class TCancelDelegationTokenReq {
 public:

  static const char* ascii_fingerprint; // = "1A3D66269336B7EC66998BFE1BECDE75";
  static const uint8_t binary_fingerprint[16]; // = {0x1A,0x3D,0x66,0x26,0x93,0x36,0xB7,0xEC,0x66,0x99,0x8B,0xFE,0x1B,0xEC,0xDE,0x75};

  TCancelDelegationTokenReq() : delegationToken() {
  }

  virtual ~TCancelDelegationTokenReq() throw() {}

  TSessionHandle sessionHandle;
  std::string delegationToken;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_delegationToken(const std::string& val) {
    delegationToken = val;
  }

  bool operator == (const TCancelDelegationTokenReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(delegationToken == rhs.delegationToken))
      return false;
    return true;
  }
  bool operator != (const TCancelDelegationTokenReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelDelegationTokenReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelDelegationTokenReq &a, TCancelDelegationTokenReq &b);


class TCancelDelegationTokenResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TCancelDelegationTokenResp() {
  }

  virtual ~TCancelDelegationTokenResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TCancelDelegationTokenResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelDelegationTokenResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelDelegationTokenResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelDelegationTokenResp &a, TCancelDelegationTokenResp &b);


class TRenewDelegationTokenReq {
 public:

  static const char* ascii_fingerprint; // = "1A3D66269336B7EC66998BFE1BECDE75";
  static const uint8_t binary_fingerprint[16]; // = {0x1A,0x3D,0x66,0x26,0x93,0x36,0xB7,0xEC,0x66,0x99,0x8B,0xFE,0x1B,0xEC,0xDE,0x75};

  TRenewDelegationTokenReq() : delegationToken() {
  }

  virtual ~TRenewDelegationTokenReq() throw() {}

  TSessionHandle sessionHandle;
  std::string delegationToken;

  void __set_sessionHandle(const TSessionHandle& val) {
    sessionHandle = val;
  }

  void __set_delegationToken(const std::string& val) {
    delegationToken = val;
  }

  bool operator == (const TRenewDelegationTokenReq & rhs) const
  {
    if (!(sessionHandle == rhs.sessionHandle))
      return false;
    if (!(delegationToken == rhs.delegationToken))
      return false;
    return true;
  }
  bool operator != (const TRenewDelegationTokenReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenewDelegationTokenReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRenewDelegationTokenReq &a, TRenewDelegationTokenReq &b);


class TRenewDelegationTokenResp {
 public:

  static const char* ascii_fingerprint; // = "7142E89F09DC7C5F6FA916C7393F46C2";
  static const uint8_t binary_fingerprint[16]; // = {0x71,0x42,0xE8,0x9F,0x09,0xDC,0x7C,0x5F,0x6F,0xA9,0x16,0xC7,0x39,0x3F,0x46,0xC2};

  TRenewDelegationTokenResp() {
  }

  virtual ~TRenewDelegationTokenResp() throw() {}

  TStatus status;

  void __set_status(const TStatus& val) {
    status = val;
  }

  bool operator == (const TRenewDelegationTokenResp & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TRenewDelegationTokenResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRenewDelegationTokenResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRenewDelegationTokenResp &a, TRenewDelegationTokenResp &b);

}}}}} // namespace

#endif
